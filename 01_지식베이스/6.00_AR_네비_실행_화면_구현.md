---
title: "6.00 AR 네비 실행 화면 구현 (핵심)"
type: "implementation"
tags: ["frontend", "ar", "navigation", "gps", "camera", "geolib"]
dependencies: ["nextjs", "react", "geolib", "deviceorientation"]
---

# 6.00 AR 네비 실행 화면 구현 (핵심)

## 워크플로우 개요

AR 네비게이션의 핵심 기능인 카메라 프리뷰, GPS 추적, 방향 화살표 표시를 구현합니다.

## 목표

- 카메라 프리뷰 표시
- GPS 위치 실시간 추적
- 방향 화살표 계산 및 표시
- 거리 계산 및 HUD 표시
- 상태 텍스트 업데이트
- 네비게이션 포인트 저장

## 단계별 작업

### 6.1 AR 네비 실행 페이지

#### 6.1.1 메인 페이지 컴포넌트
`frontend/app/ar-nav/run/page.tsx`:
```typescript
'use client';

import { useEffect, useState, useRef } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { useGeolocationWatcher } from '@/hooks/useGeolocationWatcher';
import { useHeading } from '@/hooks/useHeading';
import { useNavComputation } from '@/hooks/useNavComputation';
import { saveNavigationPoint } from '@/lib/api';
import { useNavigationStore } from '@/store/navigationStore';

export default function ArNavRunPage() {
  const router = useRouter();
  const videoRef = useRef<HTMLVideoElement>(null);
  const { currentLocation, accuracy } = useGeolocationWatcher();
  const { heading } = useHeading();
  const { targetLocation, currentSessionId } = useNavigationStore();
  
  const { distance, bearing, relativeAngle, statusText } = useNavComputation(
    currentLocation,
    targetLocation,
    heading
  );

  const [cameraActive, setCameraActive] = useState(false);

  useEffect(() => {
    startCamera();
    return () => {
      stopCamera();
    };
  }, []);

  useEffect(() => {
    if (currentLocation && currentSessionId && targetLocation) {
      saveNavigationPointToAPI();
    }
  }, [currentLocation, currentSessionId]);

  useEffect(() => {
    // 도착 감지 (5m 이내)
    if (distance !== null && distance < 5) {
      router.push('/ar-nav/arrived');
    }
  }, [distance, router]);

  const startCamera = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment' } // 후면 카메라
      });
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        setCameraActive(true);
      }
    } catch (err) {
      console.error('카메라 접근 실패:', err);
      // 카메라 없이도 동작 가능하도록 처리
    }
  };

  const stopCamera = () => {
    if (videoRef.current?.srcObject) {
      const stream = videoRef.current.srcObject as MediaStream;
      stream.getTracks().forEach(track => track.stop());
    }
  };

  const saveNavigationPointToAPI = async () => {
    if (!currentLocation || !currentSessionId || !targetLocation) return;

    try {
      await saveNavigationPoint({
        session_id: currentSessionId,
        latitude: currentLocation.lat,
        longitude: currentLocation.lng,
        heading: heading,
        accuracy: accuracy,
        distance_to_target: distance,
        bearing: bearing,
        relative_angle: relativeAngle,
      });
    } catch (err) {
      console.error('네비게이션 포인트 저장 실패:', err);
    }
  };

  const handleTestArrival = () => {
    router.push('/ar-nav/arrived');
  };

  return (
    <div className="min-h-screen bg-black text-white relative overflow-hidden">
      {/* 카메라 프리뷰 */}
      <div className="absolute inset-0">
        {cameraActive ? (
          <video
            ref={videoRef}
            autoPlay
            playsInline
            className="w-full h-full object-cover"
          />
        ) : (
          <div className="w-full h-full bg-gray-900 flex items-center justify-center">
            <p className="text-gray-500">카메라 프리뷰 영역</p>
          </div>
        )}
      </div>

      {/* 상단 HUD */}
      <div className="absolute top-0 left-0 right-0 bg-black/70 backdrop-blur-sm p-4 z-10">
        <div className="flex justify-between items-center">
          <div>
            <p className="text-2xl font-bold">
              {distance !== null ? `${Math.round(distance)}m` : '--'}
            </p>
            <p className="text-sm text-gray-400">{statusText}</p>
          </div>
          <div className="text-xs text-gray-500">
            정확도: {accuracy !== null ? `${Math.round(accuracy)}m` : '--'}
          </div>
        </div>
      </div>

      {/* 중앙 화살표 */}
      <div className="absolute inset-0 flex items-center justify-center z-20">
        <div
          className="text-6xl text-white drop-shadow-lg transition-transform duration-200"
          style={{
            transform: `rotate(${relativeAngle !== null ? relativeAngle : 0}deg)`,
          }}
        >
          ▲
        </div>
      </div>

      {/* 하단 컨트롤 */}
      <div className="absolute bottom-0 left-0 right-0 bg-black/70 backdrop-blur-sm p-6 z-10">
        <div className="flex gap-4">
          <Link
            href="/ar-nav/select"
            className="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-4 rounded-lg transition-colors text-center"
          >
            뒤로
          </Link>
          <button
            onClick={handleTestArrival}
            className="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg transition-colors"
          >
            도착 테스트
          </button>
        </div>
      </div>
    </div>
  );
}
```

### 6.2 커스텀 훅 구현

#### 6.2.1 GPS 위치 추적 훅
`frontend/hooks/useGeolocationWatcher.ts`:
```typescript
import { useState, useEffect } from 'react';

interface Location {
  lat: number;
  lng: number;
}

export function useGeolocationWatcher() {
  const [currentLocation, setCurrentLocation] = useState<Location | null>(null);
  const [accuracy, setAccuracy] = useState<number | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!navigator.geolocation) {
      setError('Geolocation is not supported');
      return;
    }

    const watchId = navigator.geolocation.watchPosition(
      (position) => {
        setCurrentLocation({
          lat: position.coords.latitude,
          lng: position.coords.longitude,
        });
        setAccuracy(position.coords.accuracy);
        setError(null);
      },
      (err) => {
        setError(err.message);
      },
      {
        enableHighAccuracy: true,
        timeout: 5000,
        maximumAge: 1000, // 1초마다 업데이트
      }
    );

    return () => {
      navigator.geolocation.clearWatch(watchId);
    };
  }, []);

  return { currentLocation, accuracy, error };
}
```

#### 6.2.2 디바이스 헤딩 훅
`frontend/hooks/useHeading.ts`:
```typescript
import { useState, useEffect } from 'react';

export function useHeading() {
  const [heading, setHeading] = useState<number | null>(null);

  useEffect(() => {
    const handleOrientation = (event: DeviceOrientationEvent) => {
      if (event.alpha !== null) {
        // alpha는 0-360도 범위의 나침반 방향
        setHeading(event.alpha);
      }
    };

    if (typeof window !== 'undefined' && window.DeviceOrientationEvent) {
      // 권한 요청 (iOS 13+)
      if (typeof (DeviceOrientationEvent as any).requestPermission === 'function') {
        (DeviceOrientationEvent as any)
          .requestPermission()
          .then((response: string) => {
            if (response === 'granted') {
              window.addEventListener('deviceorientation', handleOrientation);
            }
          });
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
      }
    }

    return () => {
      window.removeEventListener('deviceorientation', handleOrientation);
    };
  }, []);

  return { heading };
}
```

#### 6.2.3 네비게이션 계산 훅
`frontend/hooks/useNavComputation.ts`:
```typescript
import { useMemo } from 'react';
import { getDistance, getRhumbLineBearing } from 'geolib';

interface Location {
  lat: number;
  lng: number;
}

export function useNavComputation(
  currentLocation: Location | null,
  targetLocation: Location | null,
  heading: number | null
) {
  const { distance, bearing, relativeAngle, statusText } = useMemo(() => {
    if (!currentLocation || !targetLocation) {
      return {
        distance: null,
        bearing: null,
        relativeAngle: null,
        statusText: '위치 정보를 가져오는 중...',
      };
    }

    // 거리 계산 (미터 단위)
    const dist = getDistance(
      { latitude: currentLocation.lat, longitude: currentLocation.lng },
      { latitude: targetLocation.lat, longitude: targetLocation.lng }
    );

    // 방위각 계산 (0-360도)
    const bear = getRhumbLineBearing(
      { latitude: currentLocation.lat, longitude: currentLocation.lng },
      { latitude: targetLocation.lat, longitude: targetLocation.lng }
    );

    // 상대 각도 계산
    let relAngle = null;
    if (heading !== null) {
      relAngle = bear - heading;
      // -180 ~ 180 범위로 정규화
      if (relAngle > 180) relAngle -= 360;
      if (relAngle < -180) relAngle += 360;
    }

    // 상태 텍스트 결정
    let status = '방향 계산 중...';
    if (relAngle !== null) {
      const absAngle = Math.abs(relAngle);
      if (absAngle < 15) {
        status = '방향 거의 맞음';
      } else if (absAngle < 60) {
        status = '방향 조정 필요';
      } else {
        status = '큰 방향 오차';
      }
    }

    if (dist < 5) {
      status = '도착 근처';
    }

    return {
      distance: dist,
      bearing: bear,
      relativeAngle: relAngle,
      statusText: status,
    };
  }, [currentLocation, targetLocation, heading]);

  return { distance, bearing, relativeAngle, statusText };
}
```

### 6.3 API 통합

#### 6.3.1 네비게이션 포인트 저장 API
`frontend/lib/api.ts`에 추가:
```typescript
export async function saveNavigationPoint(data: {
  session_id: string;
  latitude: number;
  longitude: number;
  heading?: number;
  accuracy?: number;
  distance_to_target?: number;
  bearing?: number;
  relative_angle?: number;
}) {
  const response = await fetch(`${API_URL}/api/v1/navigation-points/`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(data),
  });
  if (!response.ok) {
    throw new Error('Failed to save navigation point');
  }
  return response.json();
}
```

## 검증 체크리스트

- [ ] 카메라 프리뷰 표시 완료
- [ ] GPS 위치 추적 구현 완료
- [ ] 디바이스 헤딩 감지 구현 완료
- [ ] 거리 계산 구현 완료
- [ ] 방위각 계산 구현 완료
- [ ] 상대 각도 계산 구현 완료
- [ ] 화살표 회전 애니메이션 구현 완료
- [ ] HUD 정보 표시 완료
- [ ] 상태 텍스트 업데이트 완료
- [ ] 네비게이션 포인트 저장 완료
- [ ] 도착 감지 로직 구현 완료

## 다음 단계

다음 워크플로우: **7.00 도착 화면 구현**

## 참고 자료

- Geolib 문서: https://www.npmjs.com/package/geolib
- DeviceOrientation API: https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent
- MediaDevices API: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia

